# -*- coding: utf-8 -*-
"""Portfolio Optimization

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G7cHEYWuhKcVmyNM-DCTXoml0jdHj8bS
"""

[]#Description: This program attempts to optimize a users portfolio using the Efficient Frontier

#Import the python libraries
from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

#Get the stock symbols tickers in the portfolio
assets = ['BABA','NRZ']

# Assign weights to the stocks.
weights=np.array([0.5,0.5,])

# Get the stock/portfolio starting date
stockStartDate='2013-01-01'

# Get the stocks ending date (today)
today = datetime.today().strftime('%Y-%m-%d')
today

# Create a dataframe to store the adjusted close price of the stocks
df = pd.DataFrame()

# Store the adjusted close price of the stock into the dataframe
for stock in assets:
  df[stock]=web.DataReader(stock,data_source='yahoo',start=stockStartDate,end=today)['Adj Close']

# Show the df
df

# Visually show the stock/portfolio
title = 'Portfolio Adj. Close Price History'

# Get the stocks
my_stocks=df

#Create and plot the graph
for c in my_stocks.columns.values:
  plt.plot(my_stocks[c],label=c)

plt.title(title)
plt.xlabel('Date',fontsize=18)
plt.ylabel('Adj Price USD($)', fontsize=18)
plt.legend(my_stocks.columns.values,loc='upper left')

# Show the daily simple return
returns = df.pct_change()
returns

# Create and show the annualized covariance matrix
cov_matrix_annual = returns.cov()*252
cov_matrix_annual

# Calculate the portfolio variance
 port_variance = np.dot(weights.T,np.dot(cov_matrix_annual,weights))
 port_variance

#Calculate the portfolio volatility aka standard deviation
port_volatility = np.sqrt(port_variance)
port_volatility

# Calculate the annual portfolio return
portfolioSimpleAnnualReturn = np.sum(returns.mean()*weights)*252
portfolioSimpleAnnualReturn

#Show the expected annual return, volatility (risk), and variance
percent_var = str(round(port_variance,2)*100) + '%'
percent_vol = str(round(port_volatility,2)*100) + '%'
percent_ret = str(round(portfolioSimpleAnnualReturn,2)*100) + '%'

print('Expected annual return: '+percent_ret)
print('Annual volatility / risk: ' + percent_vol)
print('Annual variance: '+ percent_vol)

pip install PyPortfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns
from pypfopt import black_litterman, risk_models

# Portfolio Optimization

#Calculate the expected returns and the annualized sample covariance matrix of asset returns
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

#optimilze for max sharpe ratio
ef = EfficientFrontier(mu,S)
weights=ef.max_sharpe()
cleaned_weights=ef.clean_weights()
print(cleaned_weights)
ef.portfolio_performance(verbose=True)

# Get the discrete allocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

latest_prices = get_latest_prices(df)
weights = cleaned_weights
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value=2000)
allocation, leftover = da.lp_portfolio()
print('Discrete allocation: ', allocation)
print('Funds remaing: ${:.2f}'.format(leftover))

#Black-Litterman Allocation
##delta = black_litterman.market_implied_risk_aversion(df)
#prior = black_litterman.market_implied_prior_returns(mcaps, delta, cov_matrix_annual)

#viewdict = {"AAPL": 0.20, "BBY": -0.30, "BAC": 0, "SBUX": -0.2, "T": 0.15}
#bl = BlackLittermanModel(cov_matrix, absolute_views=viewdict)

#rets = bl.bl_returns()
#ef = EfficientFrontier(rets, cov_matrix)

# OR use return-implied weights
#delta = black_litterman.market_implied_risk_aversion(market_prices)
#bl.bl_weights(delta)
weights = bl.clean_weights()